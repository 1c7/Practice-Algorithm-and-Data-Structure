弄这么一堆目录主要是为了整齐，但是也使得人不太乐意点进去看，没办法，是种取舍吧。  
[.cpp .c .py .java 文件的运行方法](Run.MD)  
每次都看 assume this is interview.py 这个文件就好了  

<br>
### 排序 (1~3天可以理解完这些)
|序号|名字|进度|一句话解释|
----|------|----|------
|1|[桶排序 - Bucket Sort(差)](./1-Sort/1. Bucket Sort)| √ | 拿 array 做, index 当做是数字, value 是这个数字出现的次数, 很差的一种排序方法, 浪费空间以及无法排序小数.
|2|[冒泡 - Bubble Sort(差)](./1-Sort/2. Bubble Sort)| √ | 每次循环跑遍所有元素, 2个2个比较, 每次循环完了之后最大的会排到后面去.
|3|[选择 - Selection Sort(差)](./1-Sort/3. Selection Sort)| √ | 每次循环找到最小的, 然后和第一个交换位置, 重复这个过程
|6|[插入 - Insertion Sort](./1-Sort/6. InsertSort)|  √
|7|[希尔 - Shell Sort - different insertion sort](./1-Sort/7. ShellSort)|  √
|4|[归并 - Merge Sort - divide & conquer](./1-Sort/4. Merge Sort) | √
|5|[快速 - Quick Sort - divide & conquer](./Grokking Algorithms An illustrated guide for programmers and other curious people/1. quicksort.py)|  √  | 随便找个数, 
|8|[堆 - Heap Sort](./1-Sort/8. Heap Sort)|   √ 
|9|[基数排序 - Radix Sort](./1-Sort/9. Radix Sort)|   √ 


<br>
### 搜索

|序号|名字|进度|一句话解释
----|------|----|-----
|1|[二分查找](./2-Search/1.BinarySearch)|   √ |
|2|[广度优先算法 - Breadth First Search - BFS](./Grokking Algorithms An illustrated guide for programmers and other curious people/3. breadth-first search.py)|   √ | 先找遍你所有的朋友,　找不到再找遍你朋友的朋友, 一层层下去.
|3|深度优先算法 - Deep First Search - DFS|

<br>
### 树  
|序号|名字|进度
----|------|----
|1|二叉搜索树 - Binary search tree| 
|2|红黑树 - Red–black tree| 
|3|B+树 - B+ tree| 


<br>
### 图
[什么是图，图能做啥](./What is Graph.md)

<br/>
<br/>





一句话解释是我自己的总结, 光看那一句话的话, 如果没理解算法的话非常正常  

























