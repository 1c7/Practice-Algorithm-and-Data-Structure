## 练算法和数据结构

<br>
### 排序
##### 序号随便的, 不是按什么规则排的
|序号|名字|进度
----|------|----
|1|[桶排序 - Bucket Sort(差)](./Sort/1. Bucket Sort)| √ 
|2|[冒泡 - Bubble Sort(差)](./Sort/2. Bubble Sort)|√   
|3|[选择 - Selection Sort](./Sort/3. Selection Sort)|√  
|4|[归并 - Merge Sort](./Sort/4. Merge Sort) | 
|5|[快速 - Quick Sort](./Sort/5.InsertSort)|  
|6|[插入 - Insertion Sort](./Sort/6.InsertSort)|  
|7|[希尔 - Shell Sort]|  
|8|[堆 - Heap Sort]|  
|9|Cocktail Sort(差) also known as bidirectional bubble sort |不实现了, 没意思  
|10|梳 - Comb Sort - Comb sort improves on bubble sort.|  
|11|Timsort is a hybrid stable sorting algorithm, derived from merge sort and insertion sort|  


<br>
### 搜索

|序号|名字|进度
----|------|----
|1|二分查找| 
|2|深度优先算法 - Deep First Search - DFS| 
|3|广度优先算法 - Breadth First Search - BFS| 



<br>
### 树
为什么需要树? 树有什么用? 实际应用在了哪些地方?   
1. 

|序号|名字|进度
----|------|----
|1|二叉搜索树 - Binary search tree| 
|2|红黑树 - Red–black tree| 
|3|[B+树 - B+ tree](./Tree/B+ Tree)| 


<br>
### 图
1. 图有什么用? 实际应用在了哪些地方?   


<br/>
<br/>
http://www.zhihu.com/question/22608820
__这两门课程该如何学？看哪些书？__这里我告诉你一个通用的办法，去美国计算机系排名靠前的大学的课程主页，找到这两门课最近几年的课程大纲、讲义、参考书目、阅读材料、随堂练习、课后作业、编程实验、期末项目等，然后你就心里有数了。

__学习任何一门课程都要善于抓住主要矛盾、分清主次、突出重点，__关键是掌握知识框架，学会以后真正有用的知识和技能，而不要把精力平均分配在一些琐事上。

比如说操作系统，应该把精力主要放在进程管理与调度、内存管理、并发编程与同步、高效的IO等等，而不要过于投入到初始化（从 BIOS 加载引导扇区、设置 GDT、进入保护模式）这种一次性任务上。我发现国内讲 Linux 内核的书往往把初始化的细节放在前几章，而国外的书通常放附录，你可以体会一下。初始化对操作系统本身而言当然是重要的，但是对于在用户态写服务程序的人来说，弄清楚为什么要打开 PC 上的 A20 地址线真的有用处吗？（这不过是个历史包袱罢了。）

__注意分清知识的层次__。就好比造汽车与开汽车的区别，我认为一个司机的技能主要体现在各种道路条件和天气状况下都能安全驾驶（城市道路、高速公路、乡间公路 X 晴、雨、雪、雾），平安到达目的地。作为一名司机，了解汽车运行的基本原理当然是好事，可以有助于更好地驾驶和排除一些常见故障。但不宜喧宾夺主，只要你不真正从事汽车设计工作，你再怎么研究发动机、传动、转向，也不可能比汽车厂的工程师强，毕竟这是人家的全职工作。而且钻研汽车构造超过一定程度之后，对开好车就没多大影响了，成了个人兴趣爱好。“有的人学着学着成了语言专家，反而忘了自己原本是要解决问题来的。”（语出孟岩 快速掌握一个语言最常用的50%）

__如果你要记住结论，一定要同时记住前提和适用条件__。在错误的场合使用原本正确的结论的搞笑例子举不胜举。





<br/>
<br/>
#### 总结
1. 深度优先搜索是一直往子节点下跑, 没有子节点了再上去, 再看看上面那一个有没有没访问过的子节点.  
2. 广度优先就是找邻居..  一层一层的找  

树的例子:  
文件系统  
族谱  
比赛晋级图  


二叉树 = 最多2个子节点, 一个左边一个右边. 允许只有左子节点或者只有右子节点, 并不是说除了叶节点之外其他节点都要有2个子节点才算  

<br/>
二叉树下面有两类: 满二叉树, 完全二叉树.

<br/>
满二叉树 = 全都有2个子节点, 深度一致  

<br/>
完全二叉树 = 全都有2个子节点, 深度不一致  

<br/>
堆是一种特殊的完全二叉树  
当一颗完全二叉树, 上级节点都比子节点小的时候, 叫做__最小堆__  
当一颗完全二叉树, 上级节点都比子节点大的时候, 叫做__最大堆__  

<br/>
堆有什么用?  
想从一堆数字里面找出最小的, 数组要遍历, 而最小堆直接拿根节点就是了  
假设现在要插入一个数字到堆里, 就根据大小, 从根节点开始, 向下比较, 找到合适的节点就插入成子节点就行了.

插入堆可以用__向上调整__或者__向下调整__  
向上调整和向下调整的区别是啥?  

<br/>
### 写代码的环境
大部分在 ubuntu 下写的(比如 .c和 .py)  
少部分在 win10 下写的 (.java 在 windows 下用 eclipse 写的)  


<br/>
### .cpp 
编译 C++ 程序要用 g++, 不能用 gcc  
```C++
g++ 2-Stack.cpp -o 2s
```

<br/>
### .c
```gcc hello.c -o a```
-o 代表 output
运行: ``` ./a ```

<br/>
### .py

```python
python3 xx.py
```

<br/>
### .java
看版本: ``` java -version ```

```java
javac xxx.java
```
跑完之后应该会有一个 xxx.class

然后运行:
```java 
java xxx
```








